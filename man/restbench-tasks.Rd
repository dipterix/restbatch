% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/task2.R
\name{restbench-tasks}
\alias{restbench-tasks}
\alias{new_task2}
\alias{restore_task2}
\title{Create/Restore a client-side task proxy}
\usage{
new_task2(fun, ..., task_name = "Noname", globals = TRUE, env = parent.frame())

restore_task2(task_name)
}
\arguments{
\item{fun, ...}{function to apply and additional parameters to be
passed to \code{\link[batchtools]{batchMap}} function}

\item{task_name}{a readable name for the task; default is \code{'Noname'}.}

\item{globals}{variables to export to the computing processes; see details.}

\item{env}{environment where the \code{'globals'} are defined}
}
\value{
If the task does not exist, the returns \code{NULL}, otherwise
returns a locked environment proxy that wraps batch task with the following
fields and methods.
}
\description{
Create/Restore a client-side task proxy
}
\details{
A task proxy manages a folder at \code{task_dir} containing all
the information necessary to perform the task. A task is a collection
of "jobs" (see its definition in \code{\link[batchtools]{batchMap}}).
The evaluation of the jobs is always in different processes with the current
R session, sometimes even different computers.

Sometimes the function \code{fun} may contains external objects that need
to be exported. For example, \code{function(x){ a+x }} has a variable
\code{a} that might be defined in somewhere else. It will raise errors
if we simply execute the function. Therefore, the task requires exporting
the variable \code{a} before executing jobs. This task could be done
automatically or manually.
If \code{globals} is \code{TRUE}, then all the external variables including
the packages needed will be automatically detected and exported.
If \code{globals} is a character vector, then only the variables indicated
will be correctly exported
If \code{globals} is \code{FALSE}, then you need to manually specify them
in \code{task$set_globals} method
}
\section{Fields}{

\describe{
\item{\code{task_name}}{task ID, a combination of user ID, task readable
name, and a 16-character random string}
\item{\code{readable_name}}{a friendly name of the task}
\item{\code{task_dir}}{task directory where the jobs are stored}
\item{\code{task_root}}{root directory where all tasks are stored}
\item{\code{reg}}{\code{'batchtools'} registry that reads batch job status}
\item{\code{njobs}}{total number of jobs in the task}
\item{\code{protocol}, \code{host}, \code{port}, \code{path_*}}{server
to be submitted to, used by \code{'submit()'} method}
\item{\code{submitted}}{whether the task has been submitted or not}
\item{\code{submitted_to}}{if the task has been submitted, then where}
\item{\code{results}}{the result of the task, should almost surely use
\code{collect()} instead}
\item{\code{collected}}{whether the results has been loaded from task
directory into the memory}
}
}

\section{Methods}{

\describe{
\item{\code{submit}}{submit or re-submit a task. If \code{'pack'} is true,
then the task files will be archived before sending to the server. This
option is required when server runs remotely.}
\item{\code{resolved}}{check whether the task has been resolved, a
combination of \code{server_status()} and \code{local_status()}. Will
raise errors if server if not running}
\item{\code{locally_resolved}}{check whether task is resolved locally without
query the server. Only used to check local files. It's possible that
server has finished but locally not resolved. See \code{download()} to
synchronize local files with the finished tasks on the server}
\item{\code{server_status}}{get task status from servers}
\item{\code{local_status}}{get task status from servers}
\item{\code{download}}{download the finished tasks from the server and
overwrite the local files. Raises error if the task is not finished remotely.
Always check server status before downloading.}
\item{\code{collect}}{collect results. It checks the status both locally
and remotely; download the task if finished; load up the results. This
function will block the session waiting for results.}
\item{\code{zip}}{create an archive that stores the task}
\item{\code{clear_registry}}{clear the registry, usually used to re-use the
task or to re-run the task}
\item{\code{reload_registry}}{reload \code{'reg'} registry under read-only
or writable modes. If the task has been submitted, please load in
read-only mode to avoid file corrects}
\item{\code{remove}}{remove the whole task from the hard drive}
}
}

\examples{

task <- new_task2(function(...){
  list(...)
}, x = 1:3, y = 1:6)

# Not submitted
task

# save task name to same other places
task_name <- task$task_name

# submit the task
if(interactive()){

  ensure_server()

  task$submit()

  task

  # once finished
  kill_server()

}

# Remove the task. You can always restore with task_name

rm(task)

task_restored <- restore_task2(task_name = task_name)

if(task_restored$submitted && task_restored$resolved()){
  task_restored$collect()
}

# clean up, remove all task files
task_restored$remove()

}
